# 자료구조

자료구조는 데이터를 저장하고 조작하기 위한 방법론이다. 이러한 방법론은 데이터의 구조, 종류, 용도 등을 고려하여 선택되며, 프로그램의 성능과 효율성에 큰 영향을 미친다.

자료구조는 효율적인 문제해결을 위한 데이터 저장 방식을 선택하는 것이다.

## 연결리스트와 배열

배열에 비해 데이터의 삽입 및 삭제가 용이하다. 배열은 데이터를 삽입하거나 삭제할 때마다 빈자리를 만들거나 채우기 위해 정렬과정이 이루어진다. 이로 인해 삽입 및 삭제의 횟수가 많다면 그때마다 정렬을 해야해서 효율적이지 않다. 배열의 삽입, 삭제는O(N)의 시간 복잡도를 갖는다. 또한 배열의 크기는 선언 이후에 변경할 수 없기 때문에, 배열의 크기에 비해 요소가 적다면 배열의 크기는 고정적이기 때문에 사용하지 않는 부분으로 인한 메모리 낭비를 유발할 수 있고, 배열의 크기보다 요소의 수가 많다면 요소를 모두 저장할 수 있는 새로운 배열을 새로 선언하고 요소를 모두 옮겨야 한다. 

하지만 연결리스트는 크기를 선언하지 않고 크기를 늘리고 줄이는 것이 자유로워서 배열에 비해 메모리 낭비가 발생하지 않는다. 또한 데이터를 삽입 또는 삭제할 때 바로 앞과 추가하는 노드가 가리키는 주소값만 변경하면 되기 때문에 더 단순하고 효율적이다. 연결리스트의 삽입과 삭제는 O(1)의 시간 복잡도를 갖는다.

배열은 인덱스를 통해서 바로 특정 위치에 접근할 수 있는 반면 연결리스트는 연결된 노드를 포인터를 통해 순차적으로 탐색해야 특정 위치의 요소에 접근할 수 있어서 탐색 속도가 떨어진다. 또한 연결리스트는 노드의 포인터를 잘못 설정했을 경우 그 이후의 데이터를 모두 잃어버릴 수 있기 때문에 불안정하다는 단점도 존재한다. 이를 보완하기 위해 각 노드가 다음노드 뿐만 아니라 이전 노드에도 접근할 수 있도록 포인터를 2개씩 갖게 하는 이중연결리스트 방식도 있다. 이중연결리스트는 데이터가 Head에 가까운지 Tail에 가까운지를 알때 단일연결리스트에 비해 탐색 속도가 빨라진다.

게다가 캐싱에서 메모리와 시간적인 부분에서 연결리스트는 더 큰 문제가 생긴다. CPU는 메모리에서 필요한 리소스를 캐싱해두고, 캐시 안에 들어있는 리소스를 레지스터로 가져와 업무를 수행한다. 하지만 연결리스트는 서로 다른 주소의 데이터를 가지고 있어서 메모리 주소를 찾을 때마다 연산 횟수가 많아지고 시간이 오래걸린다. 하지만 배열은 특정 영역에 특정 크기의 메모리를 사용하고 있기 때문에 그 영역에 접근하여 데이터를 한 번에 캐싱할 수 있다. 즉, 데이터를 찾을 때 연결리스트에 비해 연산 횟수가 줄어들고 시간도 절약할 수 있다.

배열은 메모리상에서 데이터가 흩어져 있으면 각 데이터의 주소값을 모르기 때문에 접근할 수 없으나, 연결리스트는 각 노드가 바로 다음 순서의 노드의 주소값을 가지고 있기 때문에 O(n)의 시간복잡도로 더 오래 걸릴뿐 데이터를 찾는 것이 가능하다.

탐색과 정렬이 자주 필요한 경우에는 배열을 사용하는 것이 유리하고, 데이터의 삽입과 삭제가 많다면 연결 리스트를 사용하는 것이 유리하다.

## 스택

후입선출(LIFO)로 마지막에 들어온 데이터가 TOP이 된다. pop을 사용하여 TOP인 데이터를 꺼낼 수 있고, TOP 바로 이전에 들어온 데이터가 새로운 TOP이 된다.

스택이 비어있을때 TOP은 -1을 가리키고 첫번째 데이터는 0, 두번째 데이터는 1 이런식으로 위치가 지정된다.

TOP 위치에만 데이터의 삽입과 삭제가 이루어지고 다른 위치에 대한 접근, 삽입, 삭제는 모두 불가능하므로, 삽입, 삭제의 시간 복잡도는 O(1)이다.

스택이 비어있을때 pop을 시도하면 언더플로우, 스택이 가득차있을때 push를 시도하면 오버플로우가 발생한다.

재귀 알고리즘, DFS 알고리즘, 역추적 작업(작업취소 등), 괄호 검사, 후위 연산법, 문자열 역순 출력 등에 주로 사용된다.

스택은 구조가 단순하여 구현이 쉽고, 데이터 저장과 읽기 속도가 빠르다는 장점이 있다. 또한 TOP에만 접근하기 때문에 데이터 접근, 삽입, 삭제가 빠른 것이 장점이다. 하지만 단순하고 빠른 성능을 위해 스택을 배열 구조로 구현하는 경우, 스택 구현 시 데이터 최대 개수를 미리 정해야 하기 때문에 저장 공간의 낭비가 발생할 수 있다는 단점이 있다. 또한 TOP 위치 이외에는 데이터에 접근할 수 없기 때문에 TOP이 아닌 데이터에 접근하기 위해서는 원하는 데이터가 나올 때까지 TOP에서 데이터를 꺼내는 것을 반복해야 한다는 단점도 있다.

## 큐

선입선출로 처음에 들어온 데이터가 front가 되고 enqueue를 사용하여 데이터를 추가할 수 있고, 마지막으로 들어온 데이터의 위치가 rear가 된다. 그리고 dequeue를 사용하여 front인 데이터를 꺼낼 수 있고, 꺼낸 데이터의 위치가 front가 된다.

큐는 대기열, 프로세스 관리, 너비 우선 탐색(BFS), 캐시(Cache) 등에 주로 사용된다. 먼저 온 순서대로 업무를 처리하기 위해 대기열 시스템에 활용되고, 운영체제에서 프로세스를 관리할 때, 프로세스가 CPU를 할당받기 위해 대기하는 큐를 사용한다. 또한 그래프 탐색 알고리즘에서 인접한 노트를 우선으로 방문해야 하는 경우에 큐를 사용하고, 캐시 메모리에서 데이터를 저장하고 꺼낼 때, 가장 오래된 데이터를 먼저 삭제하는 방식을 사용하여 구현할 경우 큐를 사용한다.

큐는 데이터의 먼저 들어온 순서가 중요한 작업을 수행할 때 용이하다는 장점이 있지만 큐의 크기가 고정되어 있다면 데이터가 가득 찼을 때 더 이상 삽입할 수 없다는 점과 선형큐일 경우에 데이터를 삭제할 때마다 다음의 모든 데이터의 위치를 하나씩 옮겨야 한다는 단점이 있다. 옮기지 않으면 불필요하게 공간을 낭비하게 된다. 따라서 데이터 관리가 스택에 비해 어렵고, 시간이 더 오래걸린다.

### 선형큐

선형 배열을 사용하여 구현한 큐이다. 큐의 한쪽은 front, 다른 한쪽은 rear가 된다. 큐가 비어있을때는 front와 rear의 위치가 같고, 하나의 데이터가 추가되면 front의 위치는 -1을 가리키고, rear의 위치는 0을 가리킨다. 데이터가 더 추가될 때마다 rear의 위치는 1씩 증가하고, front의 위치는 그대로 -1이다.

데이터를 삭제하거나 출력할 때는 rear의 위치는 그대로 유지되며, front 위치 바로 다음의 요소를 삭제하거나 출력하고, 삭제 시에는 front 위치가 삭제한 요소가 있던 위치를 가리킨다.

### 원형큐

원형으로 구현한 큐이다. 큐가 비어있을 때는 front와 rear의 위치가 같고, 하나의 데이터가 추가되면 front의 위치는 그대로 둔 채, rear의 위치가 1 증가하고 rear의 위치에 데이터가 저장된다. 데이터를 삭제할 때는 front 바로 다음의 순서의 위치에 있는 데이터가 삭제되고 그 자리가 front가 된다. 데이터를 출력할 때도 front 바로 다음의 순서에 있는 데이터가 첫번째 데이터이므로 그 데이터가 출력된다.  선형큐와 동일하게 삽입과 삭제가 이루어지고 배열을 기반으로 하기 때문에 크기가 고정되어 있다보니 큐가 비어있는 부분이 있을 경우에는 메모리 낭비가 발생할 수 있다. 하지만 선형큐와 달리 데이터가 삭제된 부분에 다시 삽입이 이루어질 수 있어서 큐에 삽입과 삭제를 반복하더라도 저장공간을 계속 재활용하기 때문에 비어있는 저장공간이 없다면 메모리 낭비가 발생하지 않는다.

## 덱

큐와 스택의 특징을 모두 가지고 있는 자료구조이다. 덱은 양쪽 끝에서 삽입과 삭제가 가능하다. 선입선출과 후입선출 모두 적용할 수 있다. 주로 회문처럼 앞에서 읽으나 뒤에서 읽으나 동일한 문자열을 검사할 때 사용하거나, 슬라이딩 윈도우 알고리즘을 이용해 최대값과 최소값을 검색할 때 사용된다.

파이썬에서는 collections라는 모듈에 deque라는 클래스로 덱이 이미 구현되어 있기 때문에 큐을 구현하는 것보다 덱을 쓰는 것이 편리하다는 장점이 있지만, 실제로 구현해야 한다면 큐를 구현하는 것이 더 쉽다. 그리고 스택이나 큐의 기능을 모두 수행할 수 있다는 장점이 있고, 양쪽 끝에서 데이터의 삽입과 삭제가 가능하기 때문에 데이터가 앞과 뒤 중에서 어느 쪽에서 더 가까운지를 안다면 스택과 큐에 비해 데이터에 더 빨리 접근할 수 있다는 장점이 있다. 하지만 그만큼 스택이나 큐에 비해 메모리 사용량이 크다는 단점이 있다.

## 해시맵과 해시테이블

해시맵은 해싱된 맵을 말한다. 해시맵은 Java Collections Framework에 속한 클래스이며, Map 인터페이스를 구현한 함수이다. 데이터의 저장은 key, value 형태가 되며, key 값의 hashCode를 index로 갖는 배열에 value 값을 저장한다. 이때 key값은 중복될 수 없고, value값은 중복될 수 있다. 해시맵은 검색 속도가 매우 빠르다는 점과 많은 양의 데이터를 검색하기 용이하다는 장점이 있다. key 값을 통해 바로 value 값에 접근할 수 있으므로 원하는 값을 빠르게 찾을 수 있다. 하지만 해시맵은 Map을 이용해 저장하기 때문에 저장할 때마다 빈공간을 찾아서 저장하게 되고 이로 인해 저장이 느리다는 단점이 있다. 따라서 데이터 탐색이 많이 필요한 상황에 주로 사용한다.

해시테이블도 key와 value 형태로 데이터를 저장하는 자료구조이다. 내부적으로 실제 값이 저장되는 배열(버킷)을 사용하여 데이터를 저장하고 key값을 인덱스로 삼아 값을 검색하기 때문에 데이터 검색 속도가 빠르다. 해시테이블은 데이터의 저장, 삭제, 조회의 속도가 모두 빠르며 평균 시간 복잡도는 O(1)이다. 하지만 데이터의 충돌이 발생한 경우 Chaining에 연결된 리스트들까지 검색해야하므로 O(N)까지 시간복잡도가 증가할 수 있다.

해시맵과 해시테이블은 해시값의 범위가 넓을수록 해시 충돌의 확률은 줄어들지만 메모리 사용량이 늘어나고, 해시값의 범위가 좁을수록 충돌 확률이 높아지고 메모리 사용량은 줄어든다. 이때 해시 충돌을 피하기 위해 해시테이블에서는 Chaining과 Open Addressing의 방법을 사용한다. Chaining은 중복된 해시값이 있어서 충돌이 일어난 경우, 해당 슬롯을 연결리스트로 저장하는 방법으로 최악의 경우 수행시간이 O(n)이다. 이때 트리로 구성하여 시간복잡도를 줄이기도 한다. Open Addressing은 충돌 발생 시 해시함수로 얻은 주소가 아닌 다른 주소 공간에 데이터를 저장한다. 충돌을 피하기 위해 key를 해시 테이블에 직접 저장하는 것으로, 포인터를 사용하지 않아도 되고, 구현이 간편하며, 검색도 약간 빨라진다.

자바의 경우 해시맵과 해시테이블에서 차이가 발생한다. 해시맵은 해시테이블과 비교했을 때 해시테이블에 비해 Thread 관점에서 안전하지 않은 대신 속도가 빠르다. 해시테이블도 속도가 빠르긴하지만 해시맵 보다는 더 안전한 대신 속도가 느리다. 해시테이블은 동기화가 걸려있는 반면, 해시맵은 동기화가 없어서 안전하지 않은 것이다. 해시맵에 동시에 접근할 경우에는 ConcurrentModificationException 이라는 예외가 발생할 수 있기 때문에 동시 접근에 안전하기 위해서는 해시테이블을 사용하고, 단일 Thread를 사용하면서 빠른 속도를 원한다면 해시맵을 사용한다.

## 트리

선형 데이터 구조로는 계층형 구조를 나타낼 수 없기 때문에 트리를 사용한다. 트리는 주로 탐색을 하기 위해 사용하고, 폴더 구조, DBMS, 검색 엔진 등에서 활용된다.

트리는 부모-자식 개념을 가지는 자료구조로 최상위에 있는 노드(맨 처음에 나온 부모 노드)를 루트 노드라고 하며 루트 노드는 부모를 가지지 않는다. 트리는 시간복잡도가 O(logn)으로 비교적 시간이 적게 걸리기 때문에 여러가지 부수적인 자료구조나 알고리즘을 만드는 데에도 사용된다.

### 이진 트리(Binary Tree)

부모 노드 밑의 자식 노드 개수를 최대 2개로 제한하는 트리의 가장 간단한 형태이다. 맨 처음에 나온 부모 노드가 루트가 되고 부모 노드는 자식 노드를 최대 2개까지 가지며, 자식 노드를 부모로 갖는 자식 노드도 최대 2개씩 계속 뻗어나갈 수 있다. 이때 왼쪽 자식 노드와 오른쪽 자식 노드를 구분지어서 각각을 가리길 두 개의 포인터를 가진 구조로 구현한다.

이진 트리의 종류에는 정 이진 트리(full binary tree), 포화 이진 트리(perfect binary tree), 완전 이진 트리(complete binary tree)가 있다. 정 이진 트리는 모든 트리의 자식이 0개 또는 2개인 트리이다. 포화 이진 트리는 모든 리프 노드의 높이가 같고 리프 노드가 아닌 노드는 모두 2개의 자식을 갖는 트리로, 리프 높이의 최대치가 n일 때 가장 많이 존재할 수 있는 노드의 수인 2**n -1 개를 모두 채운 이진 트리를 말한다. 따라서 모든 포화 이진 트리는 정 이진 트리라고 할 수 있다. 완전 이진 트리는 모든 리프 노드의 높이가 최대 1 차이가 나고, 모든 노드의 오른쪽 자식이 있으면 왼쪽 자식이 있는 이진 트리이다.