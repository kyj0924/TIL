# 스마트 혼합 훈련 인강 23.09.02

## 덱(Deque)

Double-ended queue의 줄임말

전단(front)와 후단(rear)에서 모두 삽입과 삭제가 가능한 큐

스택이나 큐보다 입출력이 자유로운 자료구조로 덱을 스택이나 큐로 사용할 수도 있다.

연산의 이름은 달라진다

덱의 하드웨어적인 구조는 큐와 동일하다.

기능은 큐보다 많다.

덱은 앞 뒤에서는 삽입과 삭제가 가능하지만 중간에서는 불가능하다.

add_front, add_rear로 삽입하고, delet_front, delet_rear로 삭제한다.

## 덱의 추상 자료형

**데이터** : 전단과 후단의 접근을 허용하는 항목들의 모음

**연산** : Deque(), isEmpty(), isFull(), add_front(x), delete_front(), add_rear(x), delete_rear(), get_front(), get_rear(), size(), clear(), display() 등이 있다.

## 원형 덱

원형 큐와 마찬가지로 배열을 원형으로 사용한다. 큐와 데이터는 동일하고 연산들도 기능은 유사하나 이름은 다르다.

원형 큐에서는 시계 방향으로만 회전하면 되었지만, 원형 덱에서는 반시계 방향으로도 회전할 수 있어야 한다.

원형 덱은 원형 큐 클래스를 상속해서 원형 덱 클래스를 구현할 수도 있다. 원형 덱은 원형 큐의 기능을 가지고 있고, 그 외에 추가된 기능들을 가지고 있기 때문에 상속을 통해 구현하면 원형 덱의 기능을 새로 구현할 필요가 없기 때문에 코드의 재사용성이 높아진다.

## 우선 순위 큐(Priority queue)

우선 순위의 개념을 큐에 도입한 자료구조이다.

모든 데이터가 우선 순위를 가지며 입력 순서와 상관없이 우선 순위가 높은 데이터가 먼저 출력된다.

가장 일반적인 큐로 볼 수 있다. 우선 순위를 어떻게 정하느냐에 따라 스택, 큐 또는 다른 형태의 큐를 만들 수 있기 때문이다.

가장 나중에 들어온 항목이 가장 우선 순위가 높은 형태로 설계되면 스택이고, 가장 먼저 들어온 항목이 가장 우선 순위가 높은 형태로 설계되면 큐가 된다.

우선 순위 큐는 선형 자료형으로 볼 수 없다. 큐에 들어가 있는 항목들 중에서 우선 순위가 높은 항목을 뽑기만 하면 되기 때문에 다른 항목들 사이에서 순서가 지켜질 필요가 없기 때문이다.

우선 순위 큐는 시뮬레이션, 네트워크 트래픽 제어, OS 작업 스케쥴링 등의 분야에 사용된다.

## 우선 순위 큐의 추상 자료형

**데이터** : 우선 순위를 가진 요소들의 모음

**연산** : PriorityQueue(), isEmpty(), isFull(), enqueue(e), dequeue(), peek(), size(), clear(), display() 등이 있다.

우선 순위 큐의 삭제 연산은 우선 순위가 가장 높은 항목이 제거된다.

## 우선 순위 큐의 구현 방법

선형으로 구현하려면 배열 구조 또는 연결된 구조로 구현하여 항목들을 정렬하여 저장하거나 정렬하지 않고 저장하는 방법을 사용한다.

비선형으로 구현하려면 힙 트리를 이용한다. 이 방법이 우선 순위 큐를 구현하는 가장 효율적인 방법이다. 힙트리로 구현했을 경우 삽입과 삭제 연산의 시간 복잡도가 동일하게 O(log n)이다.

## 배열 구조와 연결된 구조(예 : 링크드 리스트)

배열 구조는 항목들이 메모리에 연속적으로 저장되어 있다. 시작 항목의 주소를 알면 i번째 항목의 위치를 바로 계산할 수 있다. 즉, 배열이 아무리 커도 알고 싶은 항목의 위치를 바로 계산할 수 있다.

따라서 항목 접근의 시간 복잡도가 O(1)이다.

배열 구조는 인덱스 연산이 가능하다.

하지만 배열 구조는 삽입과 삭제 연산에서 많은 항목들의 이동이 발생하기 때문에 연산이 오래걸릴 수 있다.

연결된 구조는 배열과 달리 항목들이 메모리에 연속적으로 저장되어 있지 않아서 항목들이 모두 흩어져있다.

따라서 다음 항목을 찾기 위해서 링크가 필요하다. 링크는 데이터와 함께 노드에 저장되어 연결된 구조를 만든다. 노드에는 다음 항목의 위치가 저장된 링크가 있고, 각 노드에는 데이터가 함께 있다.

연결된 구조에서는 시작 항목을 알고 있더라도 i번째 항목의 위치를 바로 계산할 수 없다. i번째 항목을 찾기 위해서는 최대 i번의 연산이 필요하다. 즉, 링크를 하나씩 따라가야 찾을 수 있다. 그래서 연결된 구조에서는 항목 접근의 시간 복잡도가 O(n)으로 배열 구조에 비해 오래걸린다.

하지만 삽입과 삭제 연산에서는 배열보다 적은 양의 항목의 링크를 수정해서 다음 데이터의 위치를 삽입한 데이터를 가리키게 하거나 삭제한 데이터의 다음 데이터를 가리키게 수정하면 되므로 연산이 더 효율적이다.

연결된 구조는 배열 구조와 달리 용량이 고정되지 않아서 메모리의 낭비가 없고, 크기의 제한이 없기 때문에 새롭게 연결된 구조를 만들 필요가 없이 길이를 계속 늘릴 수 있어서 효율적이다.

하지만 연결된 구조는 구현이 복잡하고 항목을 탐색하는데 시간이 오래걸린다는 것이 단점이다.

### 노드(Node)

연결된 구조에서 하나의 상자를 의미하며 데이터 필드와 하나 이상의 링크 필드로 구성된다.

데이터 필드는 항목의 값을 가지고, 링크 필드는 다른 노드의 위치를 가리키는 C언어의 포인터 같은 역할을 한다.

링크는 일종의 포인터로 다른 객체를 가리키고 있는 변수와 같은 역할을 한다. 다른 노드를 가리키며, 리스트에서는 다음 노드나 이전 노드를 가리키고, 이진 트리에서는 왼쪽 자식 노드나 오른쪽 자식 노드를 가리키는 등의 역할을 한다.

헤드 포인터는 연결된 구조에서 자료 구조 객체의 유일한 정보를 가지고 있다. 시작 노드를 가리키는 포인터이다.

마지막 노드는 다음 노드가 없으므로 링크가 None이다.

노드의 종류는 다음과 같다.

**단순 연결 노드** : 하나의 링크 필드가 다음 노드를 가리켜서 노드와 노드를 연결한다.

**이중 연결 노드** : 두 개의 링크 필드로 하나는 이전 노드, 다른 하나는 다음 노드를 가리켜서 노드를 연결한다.

노드를 사용하는 링크드 리스트의 종류는 다음과 같다.

단순 연결 노드를 사용하는 단순 연결 리스트와 원형 연결 리스트가 있다. 단순 연결리스트는 헤드 포인터(시작 노드)에서 시작해서 마지막 노드의 링크는 None이 되고, 원형 연결 리스트는 마지막 노드의 링크가 헤드 포인터의 위치를 가리킨다.

이중 연결 노드를 사용하는 이중 연결 리스트는 각 노드의 링크가 이전 노드와 다음 노드를 가리켜서 단순 연결 노드를 사용할 때보다 더 안정적이게 만들 수 있다.

## 원형 연결 리스트의 마지막 노드 검사

마지막 노드의 링크가 None이 아니어야 한다.

마지막 노드의 링크가 첫번째 노드(헤드 포인터)를 가리키는지를 확인해서 마지막 노드 검사를 할 수 있다.

마지막 노드 검사 시, 무한 반복되는 알고리즘이 나타날 수 있으므로 구현에 주의해야 한다.

## 이중 연결 리스트의 장단점

단순 연결에서는 선행 노드를 찾기 위해서는 O(n)의 사간 복잡도인 것에 비해 선행 노드를 가리키는 prev 링크 필드가 있기 때문에 선행 노드를 바로 찾아갈 수 있다. O(1)의 시간 복잡도로 찾을 수 있다.

하지만 링크가 많으므로, 모든 연산에서 추가된 링크를 정확하게 관리해주어야 하고, 오류 발생 가능성과 메모리 사용이 증가한다는 단점이 있다.

## 원형 이중 연결 리스트

마지막 노드와 첫 번째 노드가 서로를 가리키고 있도록 함으로써 이중 연결 리스트를 원형으로 구현할 수도 있다.

## 정렬

데이터를 순서대로 재배열한 것으로 가장 기본적이고, 중요한 알고리즘이다.

비교할 수 있는 모든 속성들은 정렬의 기준이 될 수 있다.

정렬은 오름차순 정렬, 내림차순 정렬, 어떤 레코드를 기준으로 정렬 등의 방법이 있다.

레코드는 정렬시켜야 할 대상이다. 여러 개의 필드로 이루어져 있으며, 필드들 중에서 정렬의 기준이 되는 필드인 정렬 키가 있다.

## 정렬 알고리즘의 종류

**효율성에 따른 분류** : 알고리즘이 단순하지만 비효율적인 방법과 복잡하지만 효율적인 방법으로 나눌 수 있다.

단순하지만 비효율적인 방법에는 삽입 정렬, 선택 정렬, 버블 정렬 등이 있고, 복잡하지만 효율적인 방법에는 퀵 정렬, 힙 정렬, 병합 정렬, 기수 정렬, 팀 정렬 등이 있다.

**정렬 장소에 따른 분류** : 내부 정렬과 외부 정렬로 나눌 수 있다.

내부 정렬은 모든 데이터가 메인 메모리에 있고, 외부 정렬은 외부 기억 장치에 대부분의 레코드가 있다.

**키 값의 비교 여부에 따른 분류** : 키 값의 비교를 이용한 정렬과 배분을 이용한 정렬으로 나눈다.

대부분의 정렬 알고리즘은 키 값의 비교를 이용한 정렬에 해당된다. 두 개 이상의 레코드의 키 값을 서로 비교하여 정렬하는 방법이다.

배분을 이용한 정렬은 기수 정렬, 카운팅 정렬 등이 포함된다.

## 정렬 알고리즘의 특징

**안정성** : 동일한 키 값의 레코드가 정렬 후 상대적인 위치를 유지하는가?

정렬 후에도 본래의 위치를 유지할 경우에 안정성을 충족한다고 한다.

**제자리 정렬** : 추가적인 메모리 공간을 필요로 하는가?

정렬 중에서 추가적인 메모리 공간을 필요로 하지 않고 정렬을 완수하는 방법들은 모두 제자리 정렬이라고 할 수 있지만 복잡한 정렬 방법 중에서 병합 정렬의 경우에는 추가적인 메모리 공간이 필요하기 때문에 제자리 정렬을 충족하지 못한다.

## 선택 정렬(selection sort)

선택 정렬은 오른쪽 리스트(정렬되지 않은 리스트)에서 가장 작은 숫자를 선택해서 왼쪽 리스트(정렬이 된 리스트)의 맨 뒤로 이동하는 작업을 반복한다.

정렬되지 않은 리스트에서 가장 작은 숫자를 탐색하고, 정렬된 리스트의 맨 뒤에 추가하는 것을 반복하면 정렬된 리스트는 오름차순으로 정렬된다.

선택 정렬은 모든 요소를 정렬하기 위해 요소 개수만큼 리스트의 모든 요소를 요소 개수만큼 탐색해야 하므로 요소의 개수가 많아지면 상당히 많은 시간이 소요된다. 시간 복잡도가 O(n^2)이며, 최선과 최악의 시간 복잡도도 동일하기 때문에 비효율적이다.

선택 정렬은 기본적으로는 새로운 리스트를 사용해서 정렬하기 때문에 추가적인 메모리 공간을 필요로 해서 제자리 정렬을 충족하지 못한다. 하지만 입력 리스트를 두 부분으로 나누어서 정렬된 부분과 정렬이 되지 않은 부분으로 나누는 방식을 사용하고, 정렬이 되지 않은 부분에서 가장 작은 숫자를 찾아서 정렬이 된 부분의 첫 번째 원소와 교환하는 방식을 사용한다면 정렬된 부분이 점점 커지고, 정렬이 되지 않은 부분이 줄어들면서 하나의 리스트만으로 정렬을 완수할 수 있다.

따라서 선택 정렬을 위와 같은 방식으로 사용하면 제자리 정렬을 충족하게 만들 수 있다.

## 선택 정렬의 장단점

선택 정렬의 장점은 알고리즘이 간단하고, 제자리 정렬을 충족할 수 있고, 자료 이동 횟수를 미리 파악할 수 있다는 장점이 있다.

하지만 속도가 매우 느리고, 안정성을 만족하지 않는다는 단점이 있다.

## 버블 정렬(bubble sort)

버블 정렬은 인접한 2개의 레코드를 비교해서 순서대로 서로 교환한다.

비교-교환 과정을 리스트 전체에 수행하는 것을 스캔이라고 하고, 1번의 스캔이 완료되면 리스트의 오른쪽 끝에 가장 큰 레코드가 들어가게 된다.

버블 정렬의 시간 복잡도는 평균의 경우에는 O(n^2)이다. 최악의 경우에는 역순으로 연결된 경우이기 때문에 3배 더 오래 걸리게 되고, 이미 정렬된 경우에는 최선의 경우로 이동 횟수가 0이다.

## 버블 정렬의 장단점

버블 정렬의 장점은 알고리즘이 간단하고, 제자리 정렬을 충족할 수 있고, 안정성을 만족한다는 것이다. 하지만 최악 또는 평균적인 경우의 시간 복잡도가 O(n^2)으로 속도가 매우 느리다는 단점이 있따다. 버블 정렬은 레코드의 이동이 과다하지만, 최선의 경우와 같이 어느 정도 정렬되어 있을 때는 효과적이기 때문에 요소가 어떤 순서로 되어있는지 알고 있다면 그에 맞는 정렬을 선택할 때 버블 정렬이 효과적이라고 판단될 때 사용하면 좋다.

## 파이썬에서 집합의 원소들을 항상 정렬된 순서로 저장한다면?

파이썬에서 집합은 리스트를 사용해서 구현하기 때문에 인덱스를 사용할 수 있다. 원래 집합은 순서가 없기 때문에 인덱스를 사용하지 않지만 파이썬에서는 구현을 리스트로 하기 때문에 집합의 개념에는 맞지 않지만 두 집합의 연산에 인덱스 개념을 사용하는 것이 불가능하지는 않다. 하지만 집합의 개념 중에서 각 원소들이 유일한 값을 가져야 한다는 것은 반드시 지켜져야 한다.

정렬된 리스트로 집합을 구현하면 삽입 연산이 복잡해진다. 추가할 원소의 위치를 찾아서 끼워넣는 과정이 필요하기 때문이다.

집합의 비교나 합집합, 차집합, 교집합 연산에서 더 효율적인 알고리즘 연산이 가능해진다.

집합의 비교 연산에서 ‘=’ 연산은 우선 두 집합의 원소의 개수가 같아야 한다. 만약 원소들이 정렬되어 있지 않은 경우에는 각 원소들을 다른 집합의 모든 원소와 비교해야 하기 때문에 시간 복잡도가 O(n^2)이 되면서 비효율적인 알고리즘이 된다. 하지만 집합의 원소들이 정렬되어 있다면 원소들이 순서대로 같은 원소를 가져야 하기 때문에 시간 복잡도가 O(n)이 되면서 좀 더 효율적이게 된다.

합집합 연산 알고리즘에서는 가장 작은 원소부터 비교해서 더 작은 원소를 새로운 집합에 넣고 그 집합의 인덱스를 증가시킨다. 두 집합의 현재 원소가 같으면 하나만 넣고, 인덱스는 모두 증가 시킨다. 한쪽 집합이 모두 처리되면 나머지 집합의 남은 원소를 순서대로 새 집합에 넣는다. 이러한 방식을 사용하면 시간 복잡도가 O(n)으로 개선된다. 교집합과 차집합도 동일한 방법을 적용할 수 있다.

## 탐색

탐색은 테이블에서 원하는 탐색키를 가진 레코드를 찾는 작업이다.

테이블은 레코드의 집합이고, 탐색 키는 레코드를 서로 구별하여 인식할 수 있는 키이다.

테이블을 구성하는 방법에 따라 탐색의 효율이 달라진다.

탐색을 위한 다양한 자료구조가 있다. 맵, 딕셔너리를 예로 들 수 있다.

## 맵과 딕셔너리

맵과 딕셔너리는 탐색을 위한 자료구조로 엔트리 또는 키를 가진 레코드의 집합이다.

맵과 딕셔너리는 키와 값이 하나의 쌍으로 묶인 형태를 요소로 가진다.

키(Key)는 영어 단어와 같은 레코드를 구분할 수 있는 탐색 키이다.

값(Value)은 단어의 의미와  같이 탐색 키와 관련된 값이다.

### 파이썬의 딕셔너리

파이썬에서 제공하는 자료구조 맵이다.

각 요소는 키와 값으로 이루어져 있는 하나의 엔트리이다.

## 맵의 추상 자료형

**데이터** : 키를 가진 레코드(엔트리)의 집합

**연산** : Map(), search(key), insert(entry), delete(key), size(), clear(), display() 등의 연산이 있다.

## 맵을 구현하는 방법들

테이블 구성 방법에 따라 알고리즘과 성능이 달라진다.

맵은 엔트리를 리스트에 저장하는 방법과 엔트리를 이진 트리에 저장하는 방법, 해싱을 이용하는 방법 등으로 나눌 수 있다.

엔트리를 리스트에 저장하는 방법에는 정렬되지 않은 리스트를 이용하는 순차 탐색 맵을 구현하는 것과 정렬된 리스트를 이용해서 이진 탐색 맵을 구현하는 것이 있다.

엔트리를 이진 트리에 저장하는 방법은 이진 탐색 트리를 이용한 맵을 구현하는 것이 있다.

해싱을 이용하는 방법에는 해시 맵을 구현하는 것이 있다.

## 순차 탐색(Sequential Search)

순차 탐색은 가장 단순하고 직접적인 탐색 방법이다. 정렬되지 않은 배열을 처음부터 마지막까지 하나씩 검사한다.

순차 탐색은 테이블에 대한 특별한 조건이 없어서 어떤 테이블에 대해서도 탐색이 가능하다.

순차 탐색은 키를 탐색해서 탐색에 성공하면 해당 키의 인덱스를 반환하고, 탐색에 실패하면 -1을 반환한다.

순차 탐색을 하기 위해서는 탐색을 위한 시작과 끝 인덱스가 제공되어야 한다.

순차 탐색은 최선의 경우 1번 비교하고, 최악의 경우에는 n번 비교하고, 평균적으로는 (n+1)/2번 비교하기 때문에 시간 복잡도는 O(n)이 된다.

## 이진 탐색(Binary Search)

배열의 중앙에 있는 값을 조사하여 찾고자 하는 항목이 왼쪽 또는 오른쪽 부분 배열에 있는지를 알아내어 탐색의 범위를 반으로 줄여가면서 탐색을 진행한다.

이진 탐색을 이용하면 순차 탐색에 비해 비교 횟수를 감소시킬 수 있다.

예를 들어 10억 명 중에서 특정한 이름을 탐색한다면 순차 탐색은 평균 5억 번의 비교가 필요하고, 이진 탐색은 단지 30번의 비교가 필요하다.

이진 탐색의 조건은 테이블에서 엔트리들이 키 값에 따라 정렬되어 있어야 한다.

이진 탐색은 최선의 경우 1번 비교하고, 최악의 경우 O(log n)의 시간 복잡도를 가져서 매우 효율적인 알고리즘이다.

## 이진 탐색의 특징

매우 효율적인 탐색이 가능하다.

하지만 리스트가 반드시 정렬되어 있어야 사용할 수 있고, 데이터의 삽입과 삭제가 빈번한 응용에는 적합하지 않다.

## 보간 탐색(Interpolation Search)

보간 탐색은 이진 탐색을 개선시킨 알고리즘이다.

보간 탐색도 이진 탐색처럼 리스트가 반드시 정렬되어 있어야 사용할 수 있다.

보간 탐색은 탐색 키가 존재할 위치를 예측해서 탐색한다.

보간 탐색은 이진 탐색에서 리스트를 이등분해서 탐색하는 것과 달리 리스트를 불균등하게 분할해서 탐색한다.

탐색 값과 위치는 비례한다는 가정을 갖고 탐색한다.

보간 탐색의 예를 들면 사전이나 전화번호부를 탐색할 때 ‘ㄱ’으로 시작하는 값을 찾으려면 앞에서부터 찾고, ‘ㅎ’으로 시작하는 값을 찾으려면 뒤에서부터 찾는 식으로 접근한다.

즉, 탐색하고자 하는 값이 앞이나 뒤 중 더 가까운 곳에서 시작해서 찾는다.