# AWS 자바 수업 23.08.18

## TCP 네트워킹

### 클라이언트쪽에서 데이터를 보내고 서버쪽에서 받는 과정

**서버쪽**

1. 서버 소켓 생성
2. 서버 소켓과 소켓을 연결할 클라이언트의 IP 주소와 포트번호 설정
3. 연결 요청을 수락하면서 소켓을 생성
4. 연결이 되면 클라이언트에서 보낸 데이터를 바이트 배열로 받아서 데이터로 변환하는 과정을 거쳐서 전달받는다.

**클라이언트쪽**

1. 연결 요청
2. 서버쪽에서 연결이 수락되면 연결 성공
3. 연결이 되면 서버로 보낼 데이터를 바이트로 변경해서 바이트 배열에 저장하고, 바이트 배열을 출력 스트림에 전송

다음은 서버 소켓을 생성하고 클라이언트의 소켓과 연결하여 클라이언트쪽에서 데이터를 보내고 서버쪽에서 데이터를 받는 예제이다.

**서버쪽**

```java
package aws0818;

import java.io.InputStream;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;

public class Server {

	public static void main(String[] args) {
		
		// 서버
		ServerSocket ser = null; // 서버쪽
		
		try {
			// 1. 서버 소켓 생성
			ser = new ServerSocket();
			// 2. 서버 소켓과 소켓을 연결할 클라이언트의 IP 주소와 포트번호 설정  
			ser.bind(new InetSocketAddress("localhost", 5001));
			
			while(true) {
				System.out.println("연결되기를 기다림");
				// 3. 연결 요청을 수락하면서 소켓을 생성한다.
				Socket so = ser.accept();				
				
				// 클라이언트에서 보낸 데이터를 읽어들인다.
				byte[] b = null;
				String msg = null;
				
				// 문자열을 바이트 배열로 읽는다.
				InputStream is = so.getInputStream();
				b = new byte[100];
				int r = is.read(b);
				
				// 바이트 배열을 문자열로 바꾼다.
				// 바이트 배열을 인덱스 0부터 r까지 UTF-8로 디코딩하면서 불러온다.
				msg = new String(b, 0, r, "UTF-8");
				System.out.println("데이터 받기 성공");
				is.close();
				so.close();
			}
		}
		catch(Exception e) {}

	}

}
```

**클라이언트쪽**

```java
package aws0818;

import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.net.Socket;

public class Client {

	public static void main(String[] args) {
		// 클라이언트
		Socket s = null;
		s = new Socket();
		try {
			s = new Socket();
			System.out.println("연결요청");
			// 연결 요청을 하는 connect() 메소드
			s.connect(new InetSocketAddress("localhost", 5001));
			System.out.println("연결 성공");
			
			// 바이트 배열과 보낼 문자열 설정(서버로 전송할 데이터 설정)
			byte[]arr = null;
			String msg = null;
			// 문자열을 바이트로 변경해서 전송하기 위해 OutputStream 사용
			OutputStream os = s.getOutputStream();
			msg = "Hi Server"; // 보낼 문자열 초기화
			arr = msg.getBytes("UTF-8"); // 문자열 인코딩
			
			os.write(arr); // 바이트 배열을 출력 스트림에 전송
			System.out.println("데이터 보내기 성공");			
			os.close();
			s.close();
		}
		catch(Exception e) {}

	}

}
```

### 서버쪽에서 데이터를 보내고 클라이언트쪽에서 받는 과정

클라이언트쪽에서 보내고 서버쪽에서 받는 과정을 반대로 하면 된다. 

서버쪽에서 OutputStream으로 데이터를 바이트 단위로 보내고 클라이언트쪽에서 InputStream을 사용해서 데이터를 바이트 단위로 읽어온다.

이때 연결 요청은 클라이언트에서 하고 연결 수락은 서버에서 한다는 것은 변하지 않고 InputStream과 OutputStream만 서로 바꿔주면 된다.

## 면접 때 알아야 할 개념들

### 오버라이딩과 오버로딩의 차이점이 무엇인가?

오버라이딩은 부모 클래스에 정의되어 있는 메소드를 자식 클래스에서 재정의해서 자식 클래스에 맞게 사용하는 것으로, 부모 메소드와 선언부가 같아야 합니다. 즉, 실행부만 수정할 수 있고, 메소드 이름, 매개변수, 리턴타입은 같아야 합니다.(p293)

오버로딩은 이름은 같지만 매개변수의 개수나 타입 등이 다르게 구성된 메소드나 생성자를 여러 개 만들 수 있다는 개념입니다.(p239)

즉, 오버라이딩은 이름, 매개변수, 리턴타입이 모두 같고 실행부가 다르고, 오버로딩은 이름만 같고 매개변수, 리턴타입, 매개변수의 배치 순서 등이 달라야 한다는 점에서 차이가 있습니다.

### 자바에서의 접근 제어자에 대해 아는대로 설명해봐라

private, protected, public이 있고, 접근 제어자가 설정되지 않은 상태를 default라고 합니다. 외부에서 특정 필드나 메소드를 마음대로 변경하거나 호출할 수 없도록 하기 위해 객체를 보호하고자 할 때 사용하는 것으로, 객체의 무결성을 유지하기 위해 사용합니다. private은 같은 클래스 내에서만 접근해서 사용할 수 있게 하고, protected는 상속 받은 클래스 또는 같은 패키지 내에서만 접근해서 사용할 수 있고, public은 제한 없이 접근해서 사용할 수 있습니다. 접근 제어자를 설정하지 않으면 default로, 같은 패키지 내에서만 접근해서 사용할 수 있습니다.

이렇게 객체를 외부로부터 보호하면서 원하는 목적에 맞게 객체를 사용할 수 있게 하기 위해서 원본 객체에 영향을 주지 않으면서 필드나 메소드를 수정 및 사용하도록 getter, setter 메소드를 설정해서 사용할 수도 있습니다.

### 객체 지향 언어의 특징

크게 캡슐화, 상속, 다형성, 추상화라는 특징을 갖습니다.

캡슐화는 객체의 필드와 메소드를 하나로 묶고, 실제 구현 내용 일부를 외부에 감춰서 외부의 접근으로부터 보호하는 것을 의미합니다. 외부에서 무분별하게 접근해서 객체의 필드와 메소드를 수정한다면 목적에 맞지 않게 수정되어 객체가 손상될 수 있기 때문에 접근 제한자를 설정함으로써 객체를 보호한다는 개념입니다.

상속은 부모 객체의 코드를 자식 객체에서도 사용할 수 있게 하는 것으로, 중복 코딩을 방지하고, 문제 발생 시 부모 객체에서만 수정하면 되기 때문에 유지보수 시간도 단축시킬 수 있습니다. 또한 자식 객체에서는 메소드를 오버라이딩해서 사용할 수 있기 때문에 원하는 목적에 맞게 사용할 수 있다는 장점도 있습니다.

다형성은 같은 메소드를 호출했을 때 다른 결과값을 얻을 수 있다는 개념입니다. 추상 메소드, 인터페이스나 다른 부모 클래스에서 선언된 메소드를 자식 클래스에서 오버라이딩을 통해 다양하게 구현할 수 있다는 것입니다.

추상화는 공통된 특성들을 모아서 하나의 클래스로 만드는 것입니다. 예를 들어 A자동차와 B자동차는 핸들, 바퀴 등 공통된 요소들을 가지고 있고, 이 요소들을 모아서 하나의 추상 클래스를 구성하고 A자동차와 B자동차에서 각 요소들과 관련된 메소드를 재정의해서 다형성에 의해 각기 다른 결과를 얻을 수 있습니다.

### Abstract / interface 차이점에 대해 설명해보라

Abstract가 붙은 추상 클래스는 extends를 사용해서 상속을 통해 내부의 추상 필드와 추상 메소드를 사용하고, interface는 implements를 사용해서 구현을 통해 사용한다. 또한 추상 클래스는 다른 클래스의 부모 클래스만 될 수 있지만 interface는 다른 interface를 상속받을 수 있다는 점에서 차이가 있다. 이외에도 추상 클래스는 필드와 메소드를 선언할 때 abstract를 반드시 붙여야 하지만, 인터페이스는 생략해도 자동으로 추상으로 인식하기 때문에 생략이 가능하다. 또한 추상 클래스는 추상 메소드만을 선언할 수 있지만, 인터페이스는 default를 붙여서 일반 메소드를 선언할 수도 있다.(차이점)

두 경우 모두 상속하거나 구현하는 클래스에서 오버라이딩해서 사용할 수 있고, 독립적으로는 객체 생성을 할 수 없다. 하지만 추상클래스와는 달리 인터페이스는 상수 필드나 정적 메소드를 선언해서 인터페이스를 통해서 접근할 수 있다.

또한 인터페이스는 다중 상속이 가능하다는 점에서도 차이가 있다.

### 기본타입(primitive type)과 레퍼런스 타입(reference type)은 무엇인가?

기본타입(원시 타입)은 변수에 값 자체를 저장할 수 있고, byte, short, int, long, float, double, char, Boolean이 있습니다. 레퍼런스 타입은 참조 타입이라고도하며, 메모리 상에 객체가 있는 위치를 저장합니다. 클래스, 인터페이스, 배열, 열거형 등이 있습니다. 참조 타입에는 컬렉션 객체에서 기본 타입을 다룰 수 있게 하는 Wrapper class도 포함하고 있습니다.

### 자바 컬렉션의 대표 인터페이스를 말해봐라

List, Set, Map이 있으며 List는 중복 저장이 허용되고, 저장될 때 순서가 유지된다. Set은 중복 저장을 허용하지 않고, 저장될 때 순서가 없다. Map은 key와 value가 매칭된 형태로 저장되며, key는 중복되지 않고, 중복된 키가 저장되면 최근에 저장된 값으로 대치된다. key를 통해서 value를 얻을 수 있다.

### 자바에서 객체의 직렬화란 무엇인가?(Serialization)

메모리에 생성된 객체를 파일 또는 네트워크로 출력하기 위해 객체 스트림을 사용하는데 이때 객체를 출력하기 위해 필드값을 바이트로 변경하는 작업을 직렬화라고 한다. 반대로 직렬화된 바이트를 객체의 필드값으로 복원하는 것을 역직렬화라고 한다. 즉, JVM Heap 영역에 있는 객체를 한줄로 늘어선 바이트의 형태로 만드는 것을 객체의 직렬화라고 하고, 객체의 형태로 복원하는 것을 역직렬화라고 한다. 직렬화와 역직렬화를 할 때는 객체를 입출력할 수 있는 보조 스트림을 사용하는데 직렬화는 바이트 출력 스트림과 연결된 ObjectOutputStream을 사용해서 writeObject() 메소드를 사용하고, 역직렬화는 바이트 입력 스트림과 연결된 ObjectInputStream을 사용해서 readObject() 메소드를 사용한다.

### 배열과 ArrayList의 차이점에 대해 설명하라

배열과 ArrayList는 데이터 타입이 모두 같으면서 하나 이상의 값을 저장한 자료구조이다. 배열의 경우에는 초기에 배열의 크기를 지정해주면 변경할 수 없어서 고정 크기를 가지기 때문에 지정한 크기보다 적은 데이터가 들어가면 공간이 낭비될 수 있고, 더 많은 데이터가 들어가려면 새로 배열을 생성해주어야 한다는 단점이 있지만, ArrayList는 가변 길이를 가져서 공간이 낭비되지 않고, 데이터를 추가할 때 새로운 ArrayList를 만들 필요가 없다는 장점이 있다.

### 기본 자료형 데이터를 감싸는 Wrapper 클래스 중에서 박싱과 언박싱에 대해 설명하시오.

박싱은 기본 자료형 데이터를 Wrapper 클래스 객체로 감싸는 것을 말합니다. 언박싱이란 Wrapper 클래스 객체에 저장된 데이터를 기본 자료형 값으로 꺼내는 것을 말합니다. 자동 박싱과 자동 언박싱이 가능해서 사용하기 용이합니다. Wrapper 클래스를 사용하는 이유는 컬렉션 객체가 기본 자료형을 사용할 수 없기 때문에 참조 자료형 형태로 변환해서 사용하기 위함입니다.

```java
Integer a = 3; // 박싱
System.out.println(a+3); // 6출력, 자동 언박싱
```

### 라이브러리와 프레임워크의 차이점은 무엇이라 생각하나요?

라이브러리는 쓸만한 기능들을 모아놓은 유틸 모음집으로, 자바의 다양한 패키지, 클래스, 인터페이스 등이 정리되어 있어서 사용자가 편리하게 사용할 수 있게 해준다고 생각합니다.

프레임워크는 일정 수준 이상의 품질을 보증하는 코드를 비교적 빠르고 편하게 완성하고 유지보수 할 수 있게 구조화된 솔루션이라고 생각합니다. 이번에 저는 스프링 프레임워크로 프로젝트를 했는데, 프로젝트는 이러이러 했습니다.(프로젝트 내용과 연결해서 면접에서 설명하면 좋다)

### 스레드와 프로세스 차이란?

프로세스는 운영체제 내에 존재하며 실행 중인 프로그램을 의미한다.

스레드는 하나의 프로그램 내에서의 실행 단위로 프로세스 내에 존재한다.

게임을 예로 들면 하나의 게임을 실행하면 하나의 프로세스가 실행되고 있는 것이고, 이 프로세스 안에서 채팅을 할 수 있게 하는 등 여러 기능들을 수행할 수 있게 여러 개의 스레드가 실행되고 있는 것이다.

스레드를 구현하기 위해 Thread 클래스를 상속받은 자식 클래스를 사용하거나 Runnable 인터페이스를 구현한 클래스를 사용한다.

## 오라클 다운로드 방법

Oracle Database 21c Express Edition 설치

sql deverloper를 Windows 64-bit with JDK 11 included로 설치

## 이클립스 UTF-8 설정

eclipse → window → General → Workspace → Text file encoding → Other을 UTF-8 로 맞춰놔야 나중에 웹에 띄울 때 한글이 적용된다.

## 자바 교재 주요 페이지 정리

14, 23, 39, 131, 134, 137, 144, 156, 163, 184, 189, chapter 6 전체, 284, 288, 290, 293, 413, 428, 477, 496, 507, 510, 521, 525, 530, 532, 554, 570, 640, 641, 649, 657, 676, chapter 18, chapter 19, chapter 20