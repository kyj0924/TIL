# 스마트 혼합 훈련 인강 23.08.27

## 자료구조

컴퓨터를 효율적으로 활용하기 위해 자료들을 정리하고 조직화하는 여러 가지 구조

자료구조에는 리스트, 스택, 큐, 덱, 힙, 트리, 그래프 등 다양한 것들이 있다.

## 알고리즘

해결해야 할 어떤 문제가 주어졌을 때 문제의 해답을 구하기 위한 절차를 순서대로 명확하게 나타낸 것을 의미한다.

‘프로그램 = 알고리즘 + 자료구조’ 이기 때문에 알고리즘은 자료구조와 밀접한 관계가 있다. 예를 들면 ‘최댓값 탐색 프로그램 = 배열 + 순차 탐색’ 과 같이 알고리즘과 자료구조를 잘 조합해야 프로그램을 잘 만들 수 있다.

더 적은 데이터를 사용해서 더 짧은 시간 안에 좋은 결과를 도출하는 알고리즘이 좋은 알고리즘이다.

### 알고리즘의 조건

**입력** : 알고리즘이 입력을 받는다면 모호하지 않고 잘 정의된 입력이어야 한다. 알고리즘은 입력이 필요하지 않을 때도 있지만 입력을 갖는 경우가 많다.(0개 이상의 입력을 가진다)

**출력** : 출력은 명확하게 정의되어야 하고, 알고리즘은 1개 이상의 출력이 반드시 존재해야 한다.

**명확성** : 각 명령어의 의미는 모호하지 않고 명확해야 한다.

**유한성** : 어떤 알고리즘이라도 한정된 수의 단계 후에는 반드시 종료되어야 한다. 무한 루프처럼 끝나지 않으면 안된다.

**유효성** : 명령어들은 현재 실제로 실행 가능한 연산이어야 한다. 미래에 개발될 기술 등을 포함해서는 안된다.

### 알고리즘의 기술 방법

1. 영어나 한국어와 같은 자연어를 이용한다.
 → 사람이 이해하기 쉽게 글로 설명되어 있는 형태이다.
 → 읽기 쉽지만 단어들을 정확하게 정의하지 않으면 의미가 모호해진다.
2. 흐름도(Flow Chart)를 이용한다.
 → 알고리즘을 그림으로 표현한다. true 또는 false일 때 어떤 것을 실행하는지  등을 표현한다.
 → 직관적이고 명확하며 이해하기 쉽지만, 복잡한 알고리즘일 경우에는 표현과 식별이 어렵다.
 → 따라서 일반적인 알고리즘을 설계할 때 많이 사용되는 방법은 아니다.
3. 의사 코드(Pseudo-code, 슈도 코드)를 이용한다.
 → 의사 코드는 프로그래밍 언어를 코드로 작성하기 전에 무엇을 어떻게 동작하도록 작성할 것인지에 대하여 사람이 이해할 수 있는 언어로 작성하는 것이다. 보통 자연어와 프로그램 언어를 조합해서 사용한다.
 → 의사 코드를 작성하기 전에는 문제를 이해하고 논리적으로 해석할 줄 알아야 하며, 이후 컴퓨팅 사고로 전환하여 의사 코드를 작성하고 개발 언어로 코드를 작성한다.
 → 의사 코드로 자신이 생각한 문제 해결 방법을 남겨놓는다면 코드를 분석하는 시간을 단축시킬 수 있다.
 → 디버깅이 용이하다. 오류 코드와 본인이 작성한 의사 코드를 함께 확인하면 오류에 대한 원인 파악을 쉽게 할 수 있다.
 → 프로그래밍 언어에 익숙하지 않더라도 문제를 이해할 수 있다. 또한 의사 코드가 작성된 코드를 다른 사람이 확인할 때에도 로직을 더욱 쉽게 이해할 수 있다.
 → 프로그램을 구현할 때의 여러 가지 문제들을 감출 수 있고, 알고리즘의 핵심적인 내용에만 집중할 수 있다.
 → 논문이나 책에서 많이 사용되는 방법이다.
4. 프로그래밍 언어를 이용한다.
 → 특정 프로그래밍 언어를 사용해서 코드를 작성하고, 주석을 달아서 코드에 대한 설명을 남길 수 있다.
 → 프로그래밍 언어를 알아야 사용할 수 있고, 누구나 알아볼 수 있는 것은 아니기 때문에 가장 복잡하고 다른 사람이 봤을 때 이해가 어려울 수도 있다.
 → 알고리즘의 가장 정확한 기술이 가능하다. 하지만 실제 구현 시 많은 구체적인 사항들이 앍고리즘의 핵심적인 내용들의 이해를 방해할 수 있다.
 → 프로그래밍 언어 중에서 파이썬의 경우에는 의사 코드와 비슷하게 표현되는 부분들이 많다.

## 추상 자료형(ADT)

자료형은 데이터의 집합과 데이터에 적용할 수 있는 연산의 집합이다. 하지만 제공되는 자료형들이 표현할 수 없는 것들도 있기 때문에 이러한 것들을 표현하기 위해 추상적으로 정의한 자료형을 추상 자료형이라고 한다.

추상 자료형은 자바의 클래스나 인터페이스와 유사하다.

추상 자료형은 자료형을 추상적(수학적)으로 정의한 것으로 데이터나 연산이 무엇인지를 정의한다. 하지만 데이터나 연산을 어떻게 구현할 것인지는 정의하지 않는다. 시스템의 핵심적인 구조나 동작에만 집중한다.

추상 자료형은 기능의 구현 부분을 나타내지 않고 순수한 기능이 무엇인지 나열한 것이다.

추상 자료형의 데이터에는 추상 자료형에 속하는 자료(데이터)를 정의한다.

추상 자료형의 연산에는 데이터 사이의 연산들이 정의된다. 추상 자료형과 외부를 연결하는 인터페이스의 역할을 한다. 보통 외부에서 직접 자료를 건드리는 것은 제한된다.

## 알고리즘의 효율성 분석

알고리즘 효율성 평가 기준은 시간 효율성과 공간 효율성으로 나뉜다. 알고리즘의 실행시간이 더 짧은 알고리즘이 더 좋고, 알고리즘이 사용하는 메모리의 양이 더 적은 알고리즘이 더 좋다.

효율성을 테스트하기 위해서는 알고리즘을 구현해서 실행시간과 사용된 메모리를 실제로 측정하는 방법과 알고리즘의 효율성을 이론적으로 분석하는 방법이 있다.

실행시간 측정 방식은 반드시 구현해야 알 수 있다는 단점이 있다. 또한 동일한 하드웨어, 프로그래밍 언어, 운영체제 등 같은 조건에서 실행해야만 같은 결과를 기대할 수 있으며, 두 알고리즘을 비교할 때 동일한 테스트 데이터를 사용해야 한다는 단점이 있다. 컴퓨터의 성능에 따라 결과값이 달라질 수도 있으며, 유리한 데이터가 있을 수도 있고, 불리한 데이터가 있을 수도 있기 때문이다.

파이썬에서는 import문으로 time 모듈을 사용할 수 있다. time 모듈은 현재 시각을 저장해서 시작 시간과 종료 시간을 측정해서 실행 시간이 얼마나 걸렸는지 측정하는데 사용한다.

## 시간 복잡도

시간 복잡도 분석은 알고리즘을 직접 구현하지 않고도 가능하다는 장점이 있다. 시간 복잡도 분석은 알고리즘이 수행하는 연산의 횟수를 계산하는 것으로, 입력의 개수가 증가함에 따라 연산의 횟수가 어떤 형태로 증가하는지 파악한다.

시간 복잡도는 알고리즘이 수행하는 연산의 횟수를 나타내는 함수이고, 이 때 연산은 산술, 대입, 비교, 이동의 기본적인 연산들이다. 보통 루프 제어 연산 등은 고려되지 않는다.

복잡도 함수를 좀 더 단순화하여 나타내는 방법으로 점근적 표기(Asymptotic)이 있다. 이 표기법은 단순화 하기 위해서 최고 차수인 항 이외의 항들은 무시한다. 입력의 크기 n에 대해서 n의 값이 커질 수록(입력이 많아질수록) 최고 차항이 거의 대부분의 연산 수를 차지하기 때문이다.

점근적 표기의 대표적인 것은 빅오 표기법이 있다. O(g(n)은 증가 속도가 g(n)과 같거나 낮은 모든 복잡도 함수를 포함하는 집합이다. 복잡도 함수 증가 속도의 상한을 나타낸다.

빅오 표기법으로 시간 복잡도를 표현할 때는 최고 차항을 계수를 제외하고 표기한다. 연산의 개수가 3n^2+ 2n + 1이라고 하면 빅오 표기법으로는 O(n^2)으로 표현되는 식이다.

빅오 표기법은 두 개의 함수 f(n)과 g(n)이 주어졌을 때, 모든 n>n0에 대해 |f(n)| ≤ c|g(n)|을 만족하는 상수 c와 n0가 존재하면 f(n)=O(g(n))이다.

접근적 표기의 또 다른 것은 빅세타 표기법이 있다. 세타(g(n))은 증가 속도가 g(n)과 같은 모든 복잡도 함수들만을 포함하는 집합이다. 복잡도 함수 증가 속도의 상한인 동시에 하한이다.

### 시간 복잡도의 최선, 평균, 최악의 경우

최선의 경우를 표기하면 실행시간이 가장 적은 경우이므로, 다른 경우에 어떤 일이 발생할지 알 수 없어서 문제가 생길 수 있다.

평균적인 경우는 알고리즘의 모든 입력을 고려하고 각 입력이 발생할 확률을 고려한 평균적인 실행 시간이다. 평균에 대한 가정이 필요하고, 정확히 계산하기 어렵다는 단점이 있고, 이 경우도 최악의 경우에 어느 정도로 오래 걸리는지 알 수 없어서 대처하기 어렵다는 단점이 있다.

최악의 경우는 입력의 구성이 알고리즘의 실행 시간을 가장 많이 요구하는 경우를 말하며, 가장 중요하게 사용된다. 최악의 경우를 파악하고 그 시간을 단축시킬수록 프로그램의 효율성을 높일 수 있기 때문이다.

## 반복과 순환

반복은 for나 while과 같은 반복문을 사용하는 것이고, 순환은 자기 자신을 다시 호출하여 문제를 해결하는 것이다. 순환(recursion)은 재귀라고도 한다.

## 순환(재귀)

순환은 알고리즘이나 함수가 수행 도중에 자기 자신을 다시 호출하여 문제를 해결하는 기법이다.

정의 자체가 순환적으로 되어있는 경우에 적합하다.(팩토리얼 등)

어떤 함수가 자신을 다시 호출하는 것은 그 함수가 다른 함수를 호출하는 것과 동일하게 동작한다.

함수의 처리가 끝나기 전에 다른 함수를 호출하려면 함수 복귀를 위한 정보를 어딘가에 저장하고, 호출된 함수가 끝난 후 복귀 정보를 이용해서 복귀해야 한다. 이때, 활성 레코드와 시스템 스택이 사용된다.

활성 레코드는 함수의 복귀를 위한 정보를 저장한다. 프로그램의 복귀 주소, 매개변수, 지역변수 등을 가지고, 순환 호출이 계속될수록 스택에 활성 레코드가 쌓인다. 스택에 쌓이기 때문에 가장 마지막에 쌓인 활성 레코드를 먼저 꺼내기 때문에 가장 마지막에 호출된 재귀 함수가 먼저 실행과 종료를 수행한다.

### 순환 알고리즘의 구조

순환 호출을 하는 부분과 순환 호출을 멈추는 부분으로 나뉜다. 조건을 통해서 어떤 조건이 충족되면 순환을 멈추고 값을 리턴하고, 그 조건이 충족되지 않으면 다시 자신을 호출하는 과정을 거친다.

만약 순환 호출을 할 때 팩토리얼에서 계속 동일하게 n!를 호출하는 것처럼 문제의 크기가 줄어들지 않거나 리턴값을 부여해서 순환을 멈추는 부분이 없을 경우 무한 루프에 빠지게 되니 주의해야 한다.

대부분의 순환 알고리즘은 반복문으로 바꾸어서 작성할 수 있다.

순환 구조와 반복 구조의 시간 복잡도는 동일하다.

순환 알고리즘은 순환적인 특징을 가진 문제에 사용하면 자연스럽지만, 함수를 호출할 때 시스템 스택에 데이터가 저장되면서 오버헤드 현상이 발생할 수 있다는 단점이 있다.

오버헤드란 프로그램의 실행 흐름에서 나타나는 현상 중 하나이다. 예를 들면, 프로그램의 실행 흐름 도중에 동떨어진 위치의 코드를 실행시켜야 할 때, 추가적으로 시간,메모리,자원이 사용되는 현상이다. 이러한 현상은 특히 프로그래밍 시에 외부 함수를 사용할 때 나타난다. 실행 흐름이 도중에 끊겨버리고, 함수를 사용하기 위해 스택 메모리를 할당한다. 매개변수가 있다면 대입 연산까지 일어난다. 이 외에도 함수를 호출하기 위해 많은 과정을 진행하는데. 이 때 예상하지 못하는 자원들이 소모되는 현상이 오버헤드 현상이다.

반복 알고리즘은 수행 속도가 빠르지만, 순환적인 문제에서는 프로그램 작성이 순환 알고리즘을 사용하는 것보다 어렵다는 단점이 있다.

### 거듭 제곱 알고리즘

반복 구조의 거듭 제곱 알고리즘의 시간 복잡도는 O(n)이다. n제곱을 연산하기 위해서 n번 반복한다.

순환 구조의 거듭 제곱 알고리즘은 n제곱을 연산하기 위해서 n개의 수를 같은 개수의 그룹으로 묶어서 시간 복잡도는 k가 어떤 값의 n제곱인 수라고 한다면O(log2 k)가 된다.

순환 구조에서는 x^n을 구한다고 하면 n이 1일 때는 1을 리턴하고, n이 짝수이면 x^2를 n을 2로 나눈 횟수만큼 반복해서 곱하고 그 값을 리턴하고, n이 홀수이면 x^2을 (n-1)을 2로 나눈 횟수만큼 반복해서 곱하고 그 값에 x를 곱해서 리턴한다. 이렇게 하면 반복 구조에서는 n번 반복했지만 순환 구조에서는 n/2번 반복해서 더 빠른 속도를 낼 수 있다.

### 피보나치 수열 알고리즘

순환 구조에서 피보나치 수열을 구현하면 O(2^n)의 시간 복잡도를 갖게 되어 매우 비효율적이다. 피보나치 수열의 n번째 수를 찾기 위해서 순환 구조에서는 이미 호출했던 함수를 여러 번 중복해서 호출해야 하는 문제가 발생하기 때문에 더 비효율적이다.

반복 구조에서 피보나치 수열을 구현하면 O(n)의 시간 복잡도를 갖게 되어 순환 구조를 사용하는 것보다 효율적이다. 이전의 값과 현재의 값을 변수로 설정해서 그 값을 계속 업데이트 하면서 다음 값을 찾는 과정을 반복하기 때문에 n번째 수를 찾기 위해서 n번 반복하게 된다.

## 리스트

자료를 정리하는 방법 중 하나이자 대표적인 선형 자료 구조이다. 선형 리스트라고도 불린다.

리스트는 항목들이 순서 또는 위치를 가진다.

리스트는 가장 자유로운 선형 자료 구조이다. 임의의 위치에서 삽입과 삭제가 가능하다.

하지만 리스트의 개념을 사용하지만 리스트 내에서 항목의 접근을 제한한 자료 구조도 있다. 스택, 큐, 덱을 예로 들 수 있다.

하나의 리스트에는 같은 타입의 서로 비교할 수 있는 요소들이 저장된다.

리스트를 활용해서 할 수 있는 연산은 어떤 위치에 항목을 삽입하거나 항목을 삭제하면서 반환하거나, 리스트의 공백 여부를 검사하거나, 포화상태인지 검사하거나, 리스트의 항목의 개수를 반환하거나, 새로운 리스트를 만드는 등의 작업을 할 수 있다.

이외에도 리스트를 초기화 하거나, 리스트의 항목을 찾거나, 항목을 삭제하지 않고 반환하거나, 기존의 항목을 새로운 항목으로 대치하거나, 리스트의 맨 뒤에 항목을 삽입하거나, 맨 뒤의 항목을 삭제하고 반환하거나, 리스트를 화면에 출력하는 작업도 할 수 있다.

## 집합(SET)

리스트는 각 항목들에 위치가 있고, 항목 간에 순서가 있고, 동일한 항목의 중복을 허용하지만 집합은 위치나 순서가 없고 중복을 허용하지 않는다.

집합은 같은 타입의 유일한 원소들의 모임이다.

연산은 집합을 생성하거나, 중복되지 않는 새로운 요소를 삽입하거나, 삭제 후 반환하거나, 공집합인지를 검사하거나, 집합의 원소의 개수를 반환하거나, 집합이 특정 원소를 포함하는지 검사하거나, 다른 집합과 같은 집합인지 검사하거나, 다른 집합과 합집합이나 교집합 또는 차집합을 만들어서 반환하거나, 집합을 화면에 출력하는 등 다양한 연산이 있다.

집합은 리스트, 비트 벡터, 트리, 해싱 구조 등 다양한 방법으로 구현할 수 있다. 파이썬에선느 시퀀스 자료형으로 집합(set)을 제공한다.

## 배열(Array)과 연결 리스트(Linked List)

배열은 연결 리스트와 비교해서 이해하기 좋다. 배열은 각 요소가 배열에 저장될 때 메모리의 주소가 서로 연속되어 있다. 하지만 연결 리스트는 각 노드에 값과 다음 노드의 주소를 가리키고 있는데, 이 주소가 연속되어 있지 않고 독립적으로 떨어져 있다.

배열 구조는 구현이 비교적 간단하고 인덱스를 통해 항목에 접근하기 때문에 접근의 시간 복잡도가 O(1)으로 효율적이다. 배열의 크기가 매우 크더라도 첫 항목의 위치를 알면 n번째 항목의 위치를 바로 계산할 수 있다.

하지만 배열 구조는 삽입과 삭제 연산 시 오버헤드가 발생할 수 있고, 항목의 개수가 제한될 수도 있다. 자바의 경우에는 배열의 크기를 처음에 지정하여 배열을 생성하고, 배열의 크기를 변경할 수 없기 때문에 항목의 개수가 제한된다. 파이썬의 경우에는 배열 대신 리스트를 사용해서 append로 list의 맨 뒤에 항목을 추가하는 것은 보통은 O(1)의 시간 복잡도를 가지고 최악의 경우 O(n)의 시간 복잡도를 가지지만 리스트의 중간 어딘가에 삽입과 삭제를 할 경우에는 각 요소의 순서를 하나씩 밀거나 당겨와야 하기 때문에 그 과정에서 많은 연산이 이루어져서 값이 많다면 오랜 시간이 소요될 수 있다.

연결 리스트는 구현이 비교적 복잡하고 항목에 접근하는 연산의 시간 복잡도가 O(n)으로 비효율적이다. 연결 리스트는 특정 항목에 접근하려면 첫번째 시작 노드에서 시작해서 노드에 저장된 다음 주소로 이동하는 과정을 반복해서 특정 항목이 나올 때까지 접근해야 하므로 n번째 항목에 대해서는 n번의 접근이 필요하다.

배열은 여러 변수를 하나로 묶어서 사용하는 것이고, 하나의 식별자를 이용해서 많은 항목들을 관리한다. 배열은 반복문을 활용할 수도 있다. 배열은 기본적으로 크기가 고정되어 있다.

파이썬에서는 리스트를 복사하기 위해 기존의 리스트를 가리키는 li변수가 있다고 하면 li2 = li 라고 하면 얕은 복사가 이루어진다. 얕은 복사는 독립적인 복사가 이루어지는 것이 아니라 참조를 하기 때문에 li의 요소값이 바뀌면 li2의 값도 동일하게 바뀐다.

반면 li3 = liist(li) 라고 하면 깊은 복사가 이루어진다. 깊은 복사는 독립적인 복사가 이루어져서 li의 요소가 바뀌더라도 li3의 값은 바뀌지 않는다.

자바나 C언어에서는 배열의 크기를 지정하면 배열의 크기는 고정되지만 파이썬에서는 배열 대신 리스트를 사용하며 리스트의 용량 확장은 세 단계를 거쳐서 이루어 진다. 먼저 용량을 확장한 새로운 배열을 할당하고, 기존의 배열을 새로운 배열에 복사한다. 이후에 항목을 삽입한다. 자바에서는 이 과정을 직접 새로운 배열을 생성해서 값을 옮겨야 하지만, 파이썬은 append 연산을 수행할 때 자동으로 수행된다.

## 추상 자료형의 구현 방법

프로그래밍 기법 측면으로 분류하면 함수 기반 프로그래밍과 객체 지향 프로그래밍이 있다. 객체 지향 프로그래밍은 데이터와 연산들을 하나로 묶은 클래스를 구현하는 것으로, 데이터는 클래스의 멤버 변수이고, 연산은 클래스의 멤버 함수이다. 객체 지향 프로그래밍은 캡슐화, 정보 은닉, 상속 등의 다양한 장점을 활용할 수 있다. 함수 기반 프로그래밍의은 문제점이 있고, 보통은 추상 자료형을 객체 지향 프로그래밍으로 구현한다.

### 함수 기반 프로그래밍의 문제점

데이터는 전역변수이고 연산은 일반 함수로 사용한다면 하나의 리스트에는 좋지만 여러 개의 리스트를 만들지 못한다. 다른 방법인 데이터는 지역변수이고 연산은 일반 함수로 사용한다면 여러 개의 리스트를 만들 수는 있지만 다양한 자료구조에서 같은 연산이 있다면 같은 이름의 함수가 사용되어 어떤 자료구조에서 수행하는 것인지 혼란이 발생된다. 일반 함수는 이름의 중복이 허용되지 않기 때문에 이러한 문제가 발생하는 것이고, 해결하기 위해 method_list(), method_tree() 와 같이 복잡하게 이름을 각각 명시해주어야 한다는 단점이 있다. 따라서 보통은 추상 자료형을 구현하기 위해 객체 지향 프로그래밍을 사용한다.

### 객체 지향 프로그래밍으로 추상 자료형을 구현하는 방법

객체 지향 프로그래밍에서는 각 자료구조를 사용할 때 객체를 만들어서 각 객체를 통해서 메소드를 사용한다. 따라서 같은 이름의 메소드를 호출하더라도 객체가 다르기 때문에 어떤 자료구조에서 수행하는 것인지 파악하기 쉽고, 혼란이 발생하지 않는다. 또한 메소드의 이름이 같더라도 오버라이딩 된 것에 따라 다른 역할을 수행하기 때문에 다양한 값을 얻을 수도 있다.

객체 지향 프로그래밍에서 사용하는 대표적인 리스트 클래스에는 ArrayList가 있다. 이는 배열 구조로 구현한 리스트 클래스이며, 배열과는 다르게 가변길이를 갖는다.

객체 지향 프로그래밍에서는 클래스를 사용한다. 클래스는 객체를 정의하는 틀 또는 설계도이다. 클래스는 속성을 나타내는 멤버 변수(필드)와 동작을 나타내는 멤버 함수(메소드)를 갖는다.

## 연산자 중복

연산자 중복(Operator Overloading)은 사용자 정의 클래스의 객체들에게 ==, +, - 등의 표준 연산자들을 적용할 수 있도록 하는 기능이다. 정의를 어떻게 하느냐에 따라서 객체들을 서로 더할 수도 있고 뺄 수도 있고 비교할 수도 있다.

연산자의 중복은 피연산자에 따라 서로 다른 연산을 하도록 동일한 연산자를 중복해서 작성하는 것이다. 예를 들어 ‘+’ 덧셈 연산자의 경우에는 두 정수에 대한 덧셈 연산, 두 문자열을 합치는 연산, 두 색깔을 섞은 새로운 색깔을 만드는 연산, 두 배열을 더하는 연산 등 동일한 연산자로 다양한 역할 수행하는 다형성의 개념이 적용된다.

연산자 중복은 C++ 언어에 본래 있는 연산자만 중복이 가능하고, 피연산자의 타입이 다른 연산을 새로 정의하는 것이다. 연산자 함수로 새로운 연산 처리를 수행하는 함수를 구현해서 사용한다. 연산자 중복은 클래스와의 관계를 가지고, 피연산자에 객체를 동반한다. 클래스의 멤버 함수로 구현하며 전역함수로 구현하고 클래스에 프렌드 함수로 선언한다. 피연산자의 개수를 바꿀 수는 없고, 연산자의 우선순위 변경도 불가능하다.

연산자 함수는 operator 키워드를 이용해서 선언한다. 리턴타입 operator 연산자(매개변수리스트); 형태로 사용한다.

## ArrayList 설계

ArrayList는 파이썬에서 리스트로 구현이 가능하고, 자바에서는 컬렉션 프레임워크를 통해서 구현이 가능하다. 파이썬의 리스트로 구현할 때 객체는 멤버 변수(필드)를 갖고, 지정된 크기의 배열이다. 연산은 멤버 함수가 있고, 파이썬 리스트의 고급 연산들은 사용하지 않고 구현한다.

## 스택

후입선출(LIFO)의 개념을 가지는 자료구조이다. 선형 자료구조의 일종이며, 자료의 입출력이 후입 선출로 일어나서 가장 나중에 들어온 데이터가 가장 먼저 나간다.

스택은 입력과 역순의 출력이 필요한 다양한 응용에 사용된다.

스택은 하나의 쌓여있는 더미라고 생각하면 편하다. 스택에 삽입하는 push 연산이 이루어지면 스택의 기존 데이터 위에 쌓인다. 이 과정이 반복되면서 계속 위에 쌓이게 되면 꺼낼때는 맨 위에 있는 것부터 꺼내야 한다. 따라서 스택에서 꺼내는 pop 연산이 이루어지면 스택의 가장 위에 쌓인 최근의 데이터를 삭제하고 그 값을 리턴한다. 데이터를 삭제하지 않고 리턴하려면 peek 연산을 사용한다.

스택에서도 항목의 개수를 반환하거나 스택을 공백 상태로 만들거나 공백인지 아닌지를 검사하거나 스택을 화면에 출력하거나 삽입 또는 삭제를 하는 등의 다양한 연산을 할 수 있다.

스택은 후입선출이 필요한 경우에 사용된다. 다양한 편집기의 되돌리기 기능 등이 스택이 사용된 경우이다.

시스템 스택에도 사용된다. 시스템 스택은 함수 호출에서 복귀 주소를 저장하는 장소이며, 활성화 레코드가 저장된다. 이처럼 스택은 재귀 함수를 다루기 위해 필요한 것이다.

괄호 검사에도 스택이 사용된다. 괄호 검사의 조건은 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 하고, 같은 타입의 괄호에서 왼쪽 괄호가 오른쪽 괄호보다 먼저 나와야 하고, 서로 다른 타입의 괄호 쌍이 서로를 교차해서는 안된다. 이 조건들을 모두 만족해야 괄호가 정상적이라고 할 수 있다.

### 스택의 구현 방법

스택도 배열 구조와 연결된 구조로 구현할 수 있다. 배열 구조의 스택을 파이썬에서 구현하면 리스트를 활용해서 구현할 수 있다. 

## 큐

선입선출(FIFO) 개념을 가지는 자료구조이다. 큐는 선형 자료구조의 일종이며, 자료의 입출력이 선입선출로 일어나서 가장 먼저 들어온 데이터가 가장 먼저 나간다.

큐는 입력과 같은 순서의 출력이 필요한 응용에 사용된다. 대기열 등을 예로 들 수 있다.

큐에는 선형큐와 원형 큐가 있다.

큐는 front와 rear가 있다. front는 삭제가 일어나는 곳이고, rear는 삽입이 일어나는 곳이다. 삭제는 front에서만 가능하고, 삽입은 rear에서만 가능하다.

큐는 양쪽이 모두 뚫려있고, 데이터의 흐름은 한쪽 방향으로 진행된다.

큐는 삽입을 enqueue 연산으로, 삭제를 dequeue 연산으로 수행한다.

큐의 데이터는 선입선출의 접근 방법을 유지하는 항목들의 모임이다. 선입선출과 관련된 요소라면 어떤 것이든 넣을 수 있다.

큐의 연산은 비어있는 새로운 큐를 만들거나, 공백 상태 여부나 포화 상태 여부를 검사하거나, 데이터를 삽입하거나 삭제하여 리턴하거나 삭제하지 않고 리턴하거나 항목의 개수를 리턴하거나 큐를 공백 상태로 만들거나 큐를 화면에 출력하는 등의 연산이 있다.

큐는 컴퓨터에서 버퍼의 용도로 매우 광범위하게 사용된다.

버퍼는 컴퓨터에서 데이터를 주고 받을 때 각 주변 장치들 사이에 존재하는 속도 차이나 시간 차이를 극복하기 위한 임시 기억 장치이다. 이러한 임시 기억 장치는 선입선출이 되어야 한다.

큐는 프린터와 컴퓨터 사이의 인쇄작업, 실시간 비디오 스트리밍에서의 버퍼링, 시뮬레이션의 대기열, 통신에서의 데이터 패킷들의 모델링, 서비스 센터의 콜 큐(클라이언트와 서버의 속도 차이 극복) 등에서 사용될 수 있다.

### 큐의 구현 방법

큐는 배열 구조와 연결된 구조로 구현할 수 있다. 배열 구조의 큐 구현 방법은 선형 큐와 원형 큐로 나뉜다. 선형 큐는 배열을 선형으로 사용하는 것이고, 원형 큐는 배열을 원형으로 사용하는 것이다.

배열 구조의 큐를 위한 변수로는 front와 rear가 있다. front는 최근에 삭제가 일어난 위치이고, rear는 최근에 삽입이 일어난 위치이다. 두 변수는 현재 위치를 나타내기 위해 사용된다.

### 선형 큐

배열을 선형으로 사용하는 큐이다.

큐가 비어있을 때는 front와 rear가 모두 -1이다.

항목을 삽입하면 rear가 1씩 증가한다.

항목을 삭제하면 front가 1씩 증가한다.

선형 큐의 문제점은 삽입 시에 불필요한 항목의 이동이 필요한 경우가 발생한다. 이것은 rear가 배열의 맨 끝을 가리키는 경우에 삽입을 시도할 경우 발생한다. rear가 배열의 맨 끝을 가리키고 있을 때 삭제 연산은 배열에 값이 있다면 O(1)의 시간 복잡도를 갖는다. 하지만 삽입 연산을 시도할 경우에는 앞에 삭제로 인한 빈 공간이 있다면 삽입하기 전에 각 항목들을 앞으로 이동시키게 된다. 이때 시간 복잡도가 O(n)이 되므로 비효율적이게 된다.

이러한 선형 큐의 문제점을 해결하기 위해 배열을 원형으로 사용하는 원형 큐를 사용한다.

### 원형 큐

원형 큐는 선형 큐의 문제점을 해결하기 위해 사용한다.

원형 큐는 인덱스를 회전시키면서 배열이 꽉 차지 않는 이상 삽입 연산을 했을 때 메모리 낭비의 문제점이 발생하지 않고, 시간 복잡도도 O(1)이 된다.

원형 큐는 처음에 큐가 비어 있을 때 어느 곳이든 front와 rear가 같은 위치를 가리키면 된다. 이후에 삽입 연산이 일어나면 rear가 1씩 증가하고, 삭제 연산이 일어나면 front가 1씩 증가한다. 이렇게 반복하다보면 원형을 모두 돌아서 front와 rear가 처음 가리키던 위치로 돌아오는 형태가 된다.

따라서 원형 큐에서 공백 상태는 front와 rear가 같은 위치를 가리킬 때이고, 포화 상태는 rear의 바로 다음 위치가 front의 위치와 같을 경우이다. 원형 큐에서 front가 가리키는 위치에는 데이터가 비어있기 때문에 포화 상태는 데이터가 front 위치 빼고 모든 곳에 가득 찬 것을 의미한다.

원형 큐의 연산은 큐를 초기화하거나 큐의 전체 항목 수를 반환하거나 

원형 큐에서 큐의 전체 항목 수를 반환하는 연산을 수행할 때는 rear의 인덱스가 front의 인덱스보다 작은 경우가 생기기 때문에 이 경우에는 rear의 인덱스에 원형 큐의 전체 공간 크기(마지막 인덱스 +1)를 더한 후에 front의 인덱스를 뺀 값이 큐의 전체 항목 수가 된다.

### 큐의 활용 분야

자료구조에서의 큐 활용에는 이진 트리의 레벨 순회 알고리즘, 그래프의 탐색에서 너비 우선 탐색 알고리즘, 기수 정렬에서 레코드의 정렬을 위해 사용된다.

큐는 미로 탐색에서도 활용할 수 있다. 스택의 경우에는 깊이 우선 탐색이라는 DFS 방법을 지원하는데 큐를 활용하게 되면 너비 우선 탐색이라는 BFS 방법을 지원하게 된다.

깊이 우선 탐색은 스택을 이용한 미로 탐색으로, 현재 위치에서 가능한 방향을 스택에 저장하는 방법이다. 이후 막다른 길을 만나면 저장된 다음 위치를 꺼낸다.

너비 운영 탐색이란 큐를 이용한 미로 탐색으로, 큐에 가능한 다음 위치를 순서대로 저장한다. 막다른 길을 만나면 가장 먼저 저장된 위치를 다시 시도한다. 그래서 입구에서 가까운 위치를 먼저 탐색한다.